import {noise} from '../engine/noise/noise.js';

import { glitchcity } from './glitchcity.js';
import { pharmaforest } from './pharmaforest.js';
import { dustworld } from './dustworld.js';

export const biomes = (function() {

    const road = {
        noise: new noise.Noise({
            octaves: 6,
            persistence: 0.707,
            lacunarity: 1.8,
            exponentiation: 4.5,
            height: 0.0,
            scale: 1100.0,
            noiseType: 'simplex',
            seed: 1
        }),
        material: "whatever",
        tempValueForHeight: -100
    }
    const overallHeight = {
        noise: new noise.Noise({
            octaves: 2,
            persistence: 0.707,
            lacunarity: 1.8,
            exponentiation: 2,
            height: 500.0,
            scale: 30000.0,
            noiseType: 'simplex',
            seed: 1
        }),
    }
    const blocks = [
        new glitchcity.GlitchCity(),
        // new glitchcity.GlitchCity(),
        new pharmaforest.PharmaForest(),
        new dustworld.Dustworld(),
    ]


    class BiomeGenerator {
        GetVertexData(x,y) {
            var vertexData = {
                blockType: null,
                blendData: []
            }
            const gridSize = 10000
            const blendWidth = 750
            const currentGrid = [Math.floor(x/gridSize),Math.floor(y/gridSize)]
            var points = []

            for (let ix = currentGrid[0] - 1; ix <= currentGrid[0] + 1; ix++) {
                for (let iy = currentGrid[1] - 1; iy <= currentGrid[1] + 1; iy++) {
                    var pointX = new Math.seedrandom(ix + "X" + iy)()
                    var pointY = new Math.seedrandom(ix + "Y" + iy)()
                    var point = new THREE.Vector3((ix + pointX) * gridSize, (iy + pointY) * gridSize, 0)
        
                    points.push(point)
                }
            }

            var currentVertex = new THREE.Vector3(x,y,0)
            points.sort((a,b) => {
                var distanceA = currentVertex.distanceTo(new THREE.Vector3(a.x,a.y,0)) //TODO make everything vector2
                var distanceB = currentVertex.distanceTo(new THREE.Vector3(b.x,b.y,0))

                return distanceA - distanceB
            })
            // var closest = points[0]
            vertexData.blockType = blocks[Math.floor(new Math.seedrandom(points[0])() * blocks.length)];//TODO maybe change to mainBlockType?

            var neighborPoints = []

            // var combinedDistances = 0
            for (let i = 0; i < 2/*used to be points.length but 2 looks better*/; i++) {
                if (currentVertex.distanceTo(points[i]) - currentVertex.distanceTo(points[0]) < blendWidth) {
                    neighborPoints.push({
                        blockType: blocks[Math.floor(new Math.seedrandom(points[i])() * blocks.length)],
                        distance: currentVertex.distanceTo(points[i])
                    })

                    // combinedDistances += currentVertex.distanceTo(points[i])
                }
            }

            // if (neighborPoints.length > 1) {
                var blendTotals = 0
                for (let i = 1; i < neighborPoints.length; i++) {
                    let currentBlendRatio = ((neighborPoints[0].distance + blendWidth) - neighborPoints[i].distance) / (blendWidth * neighborPoints.length)

                    vertexData.blendData.push({
                        blockType: neighborPoints[i].blockType,
                        blendRatio: currentBlendRatio
                    })

                    blendTotals += currentBlendRatio
                }

                vertexData.blendData.unshift({
                    blockType: vertexData.blockType,
                    blendRatio: 1 - blendTotals
                })

                // console.log(vertexData)
            // }

            
            // vertexData.blendData.push({
            //     blockType: blocks[Math.floor(new Math.seedrandom(points[i])() * blocks.length)],
            //     blendRatio: currentVertex.distanceTo(closest) / nearbyVertex.distanceTo(closestToNearbyVertex)
            // })
            // console.log(vertexData)

            /*for (let ix = currentVertex.x - roadWidth; ix <= currentVertex.x + roadWidth; ix += roadWidth) {
                for (let iy = currentVertex.y - roadWidth; iy <= currentVertex.y + roadWidth; iy += roadWidth) {
                    var nearbyVertex = new THREE.Vector3(ix,iy,0)
                    points.sort((a,b) => {
                        var distanceA = nearbyVertex.distanceTo(new THREE.Vector3(a.x,a.y,0))
                        var distanceB = nearbyVertex.distanceTo(new THREE.Vector3(b.x,b.y,0))

                        return distanceA - distanceB
                    })
                    var closestToNearbyVertex = points[0]
                    var neighborBlockType = blocks[Math.floor(new Math.seedrandom(closestToNearbyVertex)() * blocks.length)]
                    
                    //if (closest != closestToNearbyVertex) { //only includes vertices within roadWidth //TODO if u  want to combine neighbor blocks, add this to if statement: && vertexData.blockType != neighborBlockType
                        vertexData.blendData.push({
                            blockType: neighborBlockType,
                            blendRatio: currentVertex.distanceTo(closest) / nearbyVertex.distanceTo(closestToNearbyVertex)
                        })
                    //}
                    // console.log(currentVertex.x + " " + nearbyVertex.x)
                }
            }
            if (!(vertexData.blendData[0].blockType == vertexData.blendData[1].blockType && vertexData.blendData[0].blockType == vertexData.blendData[2].blockType && vertexData.blendData[0].blockType == vertexData.blendData[3].blockType)) {
                console.log(vertexData)
            }*/
            // console.log(currentVertex.distanceTo(closest) / nearbyVertex.distanceTo(closestToNearbyVertex))
            // vertexData.blendRatio = currentVertex.distanceTo(closest) - nearbyVertex.distanceTo(closestToNearbyVertex)
            return vertexData
        }


        Height(x,y) {
            const vertexData = this.GetVertexData(x,y)
            // const block = vertexData.blockType

            var z = 0

            for (let i = 0; i < vertexData.blendData.length; i++) {
                z += vertexData.blendData[i].blockType.GetHeight(x,y) * vertexData.blendData[i].blendRatio
            }

            return z
            // return block.GetHeight(x, y)// + vertexData.blendRatio// + overallHeight.noise.Get(x, y)
        }

        
    
    }
  
    return {
      Biomes: BiomeGenerator
    }
  })();







// function getObjectKey() {
//     var obj = {
//         myKey: { 
//             subkey1: 1,
//             subkey2: 2
//         }
//     }
//     return obj.myKey
// }

// console.log(getObjectKey().constructor.name)
// // Object



  //this was used to generate noise
//   params.bumps = {
//     octaves: 6,
//     persistence: 0.707,
//     lacunarity: 1.8,
//     exponentiation: 4.5,
//     height: 300.0,
//     scale: 1100.0,
//     noiseType: 'simplex',
//     seed: 1
//   };
//   heightGenerators: [new HeightGenerator(this._biomes, this._bumps, offset, 100000, 100000 + 1)],